"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[207],{230(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"module-1-ros2/rclpy-examples","title":"ROS 2 Python Examples","description":"Learning Objectives","source":"@site/../docs/module-1-ros2/rclpy-examples.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/rclpy-examples","permalink":"/docs/module-1-ros2/rclpy-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/physical-ai-book/tree/main/../docs/module-1-ros2/rclpy-examples.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"URDF and Robot Modeling","permalink":"/docs/module-1-ros2/urdf-modeling"},"next":{"title":"Module 5: AI Brain Systems for Humanoid Robotics","permalink":"/docs/module-5-ai-brain-humanoid/"}}');var a=s(4848),l=s(8453);const t={},i="ROS 2 Python Examples",c={},o=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Advanced Node Patterns",id:"advanced-node-patterns",level:2},{value:"Node with Parameters",id:"node-with-parameters",level:3},{value:"Parameter Callbacks",id:"parameter-callbacks",level:3},{value:"Custom Messages and Services",id:"custom-messages-and-services",level:2},{value:"Creating Custom Messages",id:"creating-custom-messages",level:3},{value:"Using Custom Messages",id:"using-custom-messages",level:3},{value:"Actions",id:"actions",level:2},{value:"Multi-threading in ROS 2",id:"multi-threading-in-ros-2",level:2},{value:"Client-Server Communication",id:"client-server-communication",level:2},{value:"Service Client",id:"service-client",level:3},{value:"Error Handling and Best Practices",id:"error-handling-and-best-practices",level:2},{value:"Exception Handling",id:"exception-handling",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"ros-2-python-examples",children:"ROS 2 Python Examples"})}),"\n",(0,a.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement complex ROS 2 nodes in Python"}),"\n",(0,a.jsx)(n.li,{children:"Use parameters for node configuration"}),"\n",(0,a.jsx)(n.li,{children:"Create custom message and service types"}),"\n",(0,a.jsx)(n.li,{children:"Handle asynchronous operations in ROS 2"}),"\n",(0,a.jsx)(n.li,{children:"Implement action servers and clients"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-node-patterns",children:"Advanced Node Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"node-with-parameters",children:"Node with Parameters"}),"\n",(0,a.jsx)(n.p,{children:"Parameters allow nodes to be configured externally without recompilation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass ParameterNode(Node):\n    def __init__(self):\n        super().__init__('parameter_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('frequency', 1.0)\n        self.declare_parameter('robot_name', 'my_robot')\n\n        # Access parameter values\n        self.frequency = self.get_parameter('frequency').value\n        self.robot_name = self.get_parameter('robot_name').value\n\n        # Create a timer that uses the parameter\n        self.timer = self.create_timer(1.0/self.frequency, self.timer_callback)\n\n    def timer_callback(self):\n        self.get_logger().info(f'Robot {self.robot_name} at {self.frequency} Hz')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ParameterNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"parameter-callbacks",children:"Parameter Callbacks"}),"\n",(0,a.jsx)(n.p,{children:"You can also set up callbacks to handle parameter changes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rcl_interfaces.msg import ParameterDescriptor\n\nclass ParameterCallbackNode(Node):\n    def __init__(self):\n        super().__init__('parameter_callback_node')\n\n        # Declare parameter with descriptor\n        descriptor = ParameterDescriptor(\n            description='Update rate in Hz',\n            integer_range=[ParameterIntegerDescriptor(from_value=1, to_value=100)]\n        )\n        self.declare_parameter('update_rate', 10, descriptor)\n\n        # Set up parameter callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'update_rate' and param.type_ == Parameter.Type.INTEGER:\n                self.get_logger().info(f'Update rate changed to {param.value}')\n                # Update timer or other components as needed\n        return SetParametersResult(successful=True)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"custom-messages-and-services",children:"Custom Messages and Services"}),"\n",(0,a.jsx)(n.h3,{id:"creating-custom-messages",children:"Creating Custom Messages"}),"\n",(0,a.jsxs)(n.p,{children:["Create a ",(0,a.jsx)(n.code,{children:"msg"})," directory in your package and define messages in ",(0,a.jsx)(n.code,{children:".msg"})," files:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"# Point2D.msg\nfloat64 x\nfloat64 y\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-custom-messages",children:"Using Custom Messages"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from my_robot_msgs.msg import Point2D\n\nclass CustomMessageNode(Node):\n    def __init__(self):\n        super().__init__('custom_message_node')\n        self.publisher = self.create_publisher(Point2D, 'waypoints', 10)\n\n    def publish_waypoint(self, x, y):\n        msg = Point2D()\n        msg.x = x\n        msg.y = y\n        self.publisher.publish(msg)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,a.jsx)(n.p,{children:"Actions are used for long-running tasks with feedback:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nimport threading\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup())\n\n    def goal_callback(self, goal_request):\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            goal_handle.publish_feedback(feedback_msg)\n            await asyncio.sleep(1)  # Simulate work\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info('Goal succeeded')\n        return result\n"})}),"\n",(0,a.jsx)(n.h2,{id:"multi-threading-in-ros-2",children:"Multi-threading in ROS 2"}),"\n",(0,a.jsx)(n.p,{children:"ROS 2 supports multi-threading for handling multiple callbacks:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\n\nclass MultiThreadedNode(Node):\n    def __init__(self):\n        super().__init__('multi_threaded_node')\n\n        # Create separate callback groups\n        cb_group1 = MutuallyExclusiveCallbackGroup()\n        cb_group2 = MutuallyExclusiveCallbackGroup()\n\n        # Subscribers with different callback groups\n        self.sub1 = self.create_subscription(\n            String, 'topic1', self.callback1, 10, callback_group=cb_group1)\n        self.sub2 = self.create_subscription(\n            String, 'topic2', self.callback2, 10, callback_group=cb_group2)\n\n    def callback1(self, msg):\n        # This runs in its own thread\n        self.get_logger().info(f'Callback 1: {msg.data}')\n\n    def callback2(self, msg):\n        # This runs in its own thread\n        self.get_logger().info(f'Callback 2: {msg.data}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MultiThreadedNode()\n\n    # Use multi-threaded executor\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n    try:\n        executor.spin()\n    finally:\n        executor.shutdown()\n        node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"client-server-communication",children:"Client-Server Communication"}),"\n",(0,a.jsx)(n.h3,{id:"service-client",children:"Service Client"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\n\nclass ServiceClientNode(Node):\n    def __init__(self):\n        super().__init__('service_client_node')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        future = self.cli.call_async(self.req)\n        return future\n\ndef main(args=None):\n    rclpy.init(args=args)\n    client = ServiceClientNode()\n\n    future = client.send_request(1, 2)\n    rclpy.spin_until_future_complete(client, future)\n\n    response = future.result()\n    client.get_logger().info(f'Result: {response.sum}')\n\n    client.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling-and-best-practices",children:"Error Handling and Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class RobustNode(Node):\n    def __init__(self):\n        super().__init__('robust_node')\n        self.subscription = self.create_subscription(\n            String, 'topic', self.safe_callback, 10)\n\n    def safe_callback(self, msg):\n        try:\n            # Process message\n            processed_data = self.process_message(msg)\n            self.publish_result(processed_data)\n        except Exception as e:\n            self.get_logger().error(f'Error processing message: {e}')\n            # Optionally publish error status or take corrective action\n"})}),"\n",(0,a.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from rclpy.lifecycle import LifecycleNode, LifecycleState\nfrom rclpy.lifecycle import TransitionCallbackReturn\n\nclass LifecycleExample(LifecycleNode):\n    def __init__(self):\n        super().__init__('lifecycle_example')\n        self.timer = None\n\n    def on_configure(self, state: LifecycleState):\n        self.get_logger().info('Configuring')\n        # Initialize resources but don't start operations\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state: LifecycleState):\n        self.get_logger().info('Activating')\n        # Start operations\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state: LifecycleState):\n        self.get_logger().info('Deactivating')\n        # Stop operations but keep resources\n        if self.timer:\n            self.timer.cancel()\n            self.timer = None\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state: LifecycleState):\n        self.get_logger().info('Cleaning up')\n        # Clean up resources\n        return TransitionCallbackReturn.SUCCESS\n"})}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"This chapter covered advanced ROS 2 Python programming patterns including parameters, custom messages, actions, multi-threading, and lifecycle nodes. These patterns enable the development of robust, configurable, and maintainable robotic applications."}),"\n",(0,a.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create a node that uses parameters to configure its behavior"}),"\n",(0,a.jsx)(n.li,{children:"Implement a custom message type and use it in a publisher/subscriber pair"}),"\n",(0,a.jsx)(n.li,{children:"Create an action server that performs a long-running task with feedback"}),"\n",(0,a.jsx)(n.li,{children:"Implement a multi-threaded node that handles multiple subscriptions simultaneously"}),"\n",(0,a.jsx)(n.li,{children:"Create a lifecycle node and test its different states"}),"\n",(0,a.jsx)(n.li,{children:"Implement a client that calls multiple services asynchronously"}),"\n",(0,a.jsx)(n.li,{children:"Use the examples in the docs/module-1-ros2/examples/ directory and run them"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/humble/p/rclpy/",children:"rclpy API Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/humble/How-To-Guides/Using-Parameters-In-A-Class-Python.html",children:"ROS 2 Parameters Guide"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Actions.html",children:"ROS 2 Actions Guide"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/humble/How-To-Guides/Using-Executors.html",children:"ROS 2 Threading Guide"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>i});var r=s(6540);const a={},l=r.createContext(a);function t(e){const n=r.useContext(l);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);